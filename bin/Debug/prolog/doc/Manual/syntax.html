<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog 6.3.7 Reference Manual: Section 2.15</title><link rel="home" href="index.html">
<link rel="contents" href="Contents.html">
<link rel="index" href="DocIndex.html">
<link rel="summary" href="summary.html">
<link rel="previous" href="gc.html">
<link rel="next" href="cyclic.html">

<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

dt.multidef
{ background-color: #c8ffc7;
}

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}
</style>
</head>
<body bgcolor="white">
<div class="navigate"><a class="nav" href="index.html"><img src="home.gif" border=0 alt="Home"></A>
<a class="nav" href="Contents.html"><img src="index.gif" border=0 alt="Contents"></A>
<a class="nav" href="DocIndex.html"><img src="yellow_pages.gif" border=0 alt="Index"></A>
<a class="nav" href="summary.html"><img src="info.gif" border=0 alt="Summary"></A>
<a class="nav" href="gc.html"><img src="prev.gif" border=0 alt="Previous"></A>
<a class="nav" href="cyclic.html"><img src="next.gif" border=0 alt="Next"></A>
</div>

<h2><a name="sec:2.15"><span class="sec-nr">2.15</span> <span class="sec-title">Syntax 
Notes</span></a></h2>

<a name="sec:syntax"></a>

<p>SWI-Prolog syntax is close to ISO-Prolog standard syntax, which is 
closely compatible with Edinburgh Prolog syntax. A description of this 
syntax can be found in the Prolog books referenced in the introduction. 
Below are some non-standard or non-common constructs that are accepted 
by SWI-Prolog:

<p>
<ul class="latex">
<li><i><code>/* ... /* ... */ ... */</code></i><br>
The <code>/* ... */</code> comment statement can be nested. This is 
useful if some code with <code>/* ... */</code> comment statements in it 
should be commented out.
</ul>

<h3><a name="sec:2.15.1"><span class="sec-nr">2.15.1</span> <span class="sec-title">ISO 
Syntax Support</span></a></h3>

<a name="sec:isosyntax"></a>

<p>SWI-Prolog offers ISO compatible extensions to the Edinburgh syntax.

<h4><a name="sec:2.15.1.1"><span class="sec-nr">2.15.1.1</span> <span class="sec-title">Processor 
Character Set</span></a></h4>

<a name="sec:processorcharset"></a>

<p><a name="idx:ISOLatin1:170"></a><a name="idx:characterset:171"></a>The 
processor character set specifies the class of each character used for 
parsing Prolog source text. Character classification is fixed to use 
UCS/Unicode as provided by the C-library <code>wchar_t</code> based 
primitives. See also <a class="sec" href="widechars.html">section 2.18</a>.

<h4><a name="sec:2.15.1.2"><span class="sec-nr">2.15.1.2</span> <span class="sec-title">Character 
Escape Syntax</span></a></h4>

<a name="sec:charescapes"></a>

<p>Within quoted atoms (using single quotes: <code>'&lt;atom&gt;'</code>) 
special characters are represented using escape sequences. An escape 
sequence is led in by the backslash (<code><code>\</code></code>) 
character. The list of escape sequences is compatible with the ISO 
standard but contains some extensions, and the interpretation of 
numerically specified characters is slightly more flexible to improve 
compatibility. Undefined escape characters raise a <code>syntax_error</code> 
exception.<sup class="fn">15<span class="fn-text">Up to SWI-Prolog&nbsp;6.1.9, 
undefined escape characters were copied verbatim, i.e., removing the 
backslash.</span></sup>

<dl class="latex">
<dt><code>\a</code></dt>
<dd class="defbody">
Alert character. Normally the ASCII character 7 (beep).
</dd>
<dt><code>\b</code></dt>
<dd class="defbody">
Backspace character.
</dd>
<dt><code>\c</code></dt>
<dd class="defbody">
No output. All input characters up to but not including the first 
non-layout character are skipped. This allows for the specification of 
pretty-looking long lines. Not supported by ISO. Example:

<pre class="code">
format('This is a long line that looks better if it was \c
       split across multiple physical lines in the input')
</pre>

</dd>
<dt><code>\&lt;<var><font size=-1>NEWLINE</font></var>&gt;</code></dt>
<dd class="defbody">
When in ISO mode (see the Prolog flag <a class="flag" href="flags.html#flag:iso">iso</a>), 
only skip this sequence. In native mode, white-space that follows the 
newline are skipped as well and a warning is printed, indicating that 
this construct is deprecated and advicing to use <code>\c</code>. We 
advise using <code>\c</code> or putting the layout <em>before</em> the <code><code>\</code></code>, 
as shown below. Using
<code>\c</code> is supported by various other Prolog implementations and 
will remain supported by SWI-Prolog. The style shown below is the most 
compatible solution.<sup class="fn">16<span class="fn-text">Future 
versions will interpret <code><code>\</code></code>&lt;<var>return</var>&gt; 
according to ISO.</span></sup>

<pre class="code">
format('This is a long line that looks better if it was \
split across multiple physical lines in the input')
</pre>

<p>instead of

<pre class="code">
format('This is a long line that looks better if it was\
 split across multiple physical lines in the input')
</pre>

</dd>
<dt><code>\e</code></dt>
<dd class="defbody">
Escape character (<font size=-1>ASCII</font> 27). Not ISO, but widely 
supported.
</dd>
<dt><code>\f</code></dt>
<dd class="defbody">
Form-feed character.
</dd>
<dt><code>\n</code></dt>
<dd class="defbody">
Next-line character.
</dd>
<dt><code>\r</code></dt>
<dd class="defbody">
Carriage-return only (i.e., go back to the start of the line).
</dd>
<dt><code>\s</code></dt>
<dd class="defbody">
Space character. Intended to allow writing <code>0'\s</code> to get the 
character code of the space character. Not ISO.
</dd>
<dt><code>\t</code></dt>
<dd class="defbody">
Horizontal tab-character.
</dd>
<dt><code>\v</code></dt>
<dd class="defbody">
Vertical tab-character (<font size=-1>ASCII</font> 11).
</dd>
<dt><code>\<code>xXX..\</code></code></dt>
<dd class="defbody">
Hexadecimal specification of a character. The closing <code>\</code> is 
obligatory according to the ISO standard, but optional in SWI-Prolog to 
enhance compatibility with the older Edinburgh standard. The code
<code>\xa\3</code> emits the character 10 (hexadecimal `a') followed by 
`3'. Characters specified this way are interpreted as Unicode 
characters. See also <code>\u</code>.
</dd>
<dt><code>\uXXXX</code></dt>
<dd class="defbody">
Unicode character specification where the character is specified using
<em>exactly</em> 4 hexadecimal digits. This is an extension to the ISO 
standard fixing two problems. First of all, where <code>\x</code> 
defines a numeric character code, it doesn't specify the character set 
in which the character should be interpreted. Second, it is not needed 
to use the idiosyncratic closing <code><code>\</code></code> ISO Prolog 
syntax.
</dd>
<dt><code>\UXXXXXXXX</code></dt>
<dd class="defbody">
Same as <code>\uXXXX</code>, but using 8 digits to cover the whole 
Unicode set.
</dd>
<dt><code>\40</code></dt>
<dd class="defbody">
Octal character specification. The rules and remarks for hexadecimal 
specifications apply to octal specifications as well.
</dd>
<dt><code>\<code>\</code></code></dt>
<dd class="defbody">
Escapes the backslash itself. This, <code>'\\'</code> is an atom 
consisting of a single <code><code>\</code></code>.
</dd>
<dt><code>\quote</code></dt>
<dd class="defbody">
If the current quote (<code>"</code> or <code>'</code>) is preceeded by 
a backslash, it is copied verbatim. Thus, <code>'\''</code> and <code>''''</code> 
both describe the atom with a single&nbsp;<code>'</code>.
</dd>
</dl>

<p>Character escaping is only available if
<code>current_prolog_flag(character_escapes, true)</code> is active 
(default). See <a name="idx:currentprologflag2:172"></a><a class="pred" href="flags.html#current_prolog_flag/2">current_prolog_flag/2</a>. 
Character escapes conflict with <a name="idx:writef2:173"></a><a class="pred" href="format.html#writef/2">writef/2</a> 
in two ways: <code>\40</code> is interpreted as decimal 40 by <a name="idx:writef2:174"></a><a class="pred" href="format.html#writef/2">writef/2</a>, 
but as octal 40 (decimal 32) by <code>read</code>. Also, the <a name="idx:writef2:175"></a><a class="pred" href="format.html#writef/2">writef/2</a> 
sequence
<code>\l</code> is illegal. It is advised to use the more widely 
supported
<a name="idx:format23:176"></a><a class="pred" href="format.html#format/2">format/[2,3]</a> 
predicate instead. If you insist upon using <a name="idx:writef2:177"></a><a class="pred" href="format.html#writef/2">writef/2</a>, 
either switch <a class="flag" href="flags.html#flag:character_escapes">character_escapes</a> 
to <code>false</code>, or use double <code>\\</code>, as in <code>writef('\\l')</code>.

<h4><a name="sec:2.15.1.3"><span class="sec-nr">2.15.1.3</span> <span class="sec-title">Syntax 
for non-decimal numbers</span></a></h4>

<a name="sec:nondecsyntax"></a>

<p>SWI-Prolog implements both Edinburgh and ISO representations for 
non-decimal numbers. According to Edinburgh syntax, such numbers are 
written as <code>&lt;<var>radix</var>&gt;'&lt;number&gt;</code>, where &lt;<var>radix</var>&gt; 
is a number between 2 and 36. ISO defines binary, octal and hexadecimal 
numbers using
<code>0<em>[bxo]</em>&lt;<var>number</var>&gt;</code>. For example: <code>A is 0b100 \/ 0xf00</code> 
is a valid expression. Such numbers are always unsigned.

<h4><a name="sec:2.15.1.4"><span class="sec-nr">2.15.1.4</span> <span class="sec-title">Unicode 
Prolog source</span></a></h4>

<a name="sec:unicodesyntax"></a>

<p>The ISO standard specifies the Prolog syntax in ASCII characters. As 
SWI-Prolog supports Unicode in source files we must extend the syntax. 
This section describes the implication for the source files, while 
writing international source files is described in <a class="sec" href="projectfiles.html">section 
3.1.3</a>.

<p>The SWI-Prolog Unicode character classification is based on version 
6.0.0 of the Unicode standard. Please note that <a name="idx:chartype2:178"></a><a class="pred" href="chartype.html#char_type/2">char_type/2</a> 
and friends, intended to be used with all text except Prolog source 
code, is based on the C-library locale-based classification routines.

<p>
<ul class="latex">
<li><i>Quoted atoms and strings</i><br>
Any character of any script can be used in quoted atoms and strings. The 
escape sequences <code>\uXXXX</code> and <code>\UXXXXXXXX</code> (see
<a class="sec" href="syntax.html">section 2.15.1.2</a>) were introduced 
to specify Unicode code points in ASCII files.

<p>
<li><i>Atoms and Variables</i><br>
We handle them in one item as they are closely related. The Unicode 
standard defines a syntax for identifiers in computer languages.<sup class="fn">17<span class="fn-text"><a class="url" href="http://www.unicode.org/reports/tr31/">http://www.unicode.org/reports/tr31/</a></span></sup> 
In this syntax identifiers start with <code>ID_Start</code> followed by 
a sequence of <code>ID_Continue</code> codes. Such sequences are handled 
as a single token in SWI-Prolog. The token is a <em>variable</em> iff it 
starts with an uppercase character or an underscore (<code>_</code>). 
Otherwise it is an atom. Note that many languages do not have the notion 
of character-case. In such languages variables <em>must</em> be written 
as
<code>_name</code>.

<p>
<li><i>White space</i><br>
All characters marked as separators (Z*) in the Unicode tables are 
handled as layout characters.

<p>
<li><i>Control and unassigned characters</i><br>
Control and unassigned (C*) characters produce a syntax error if 
encountered outside quoted atoms/strings and outside comments.

<p>
<li><i>Other characters</i><br>
The first 128 characters follow the ISO Prolog standard. Unicode symbol 
and punctuation characters (general category S* and P*) act as glueing 
symbol characters (i.e., just like <code><code>==</code></code>: an 
unquoted sequence of symbol characters are combined into an atom).

<p>Other characters (this is mainly <code>No</code>: <i>a numeric 
character of other type</i>) are currently handled as `solo'.
</ul>

<h4><a name="sec:2.15.1.5"><span class="sec-nr">2.15.1.5</span> <span class="sec-title">Singleton 
variable checking</span></a></h4>

<a name="sec:singleton"></a>

<p><a name="idx:singletonvariable:179"></a><a name="idx:anonymousvariable:180"></a>A <em>singleton 
variable</em> is a variable that appears only one time in a clause. It 
can always be replaced by <code>_</code>, the
<em>anonymous</em> variable. In some cases however people prefer to give 
the variable a name. As mistyping a variable is a common mistake, Prolog 
systems generally give a warning (controlled by <a name="idx:stylecheck1:181"></a><a class="pred" href="debugger.html#style_check/1">style_check/1</a>) 
if a variable is used only once. The system can be informed a variable 
is known to appear once by <em>starting</em> it with an underscore. E.g. <code>_Name</code>. 
Please note that any variable, except plain <code>_</code>, shares with 
variables of the same name. The term <code>t(_X, _X)</code> is 
equivalent to <code>t(X, X)</code>, which is <em>different</em> from
<code>t(_, _)</code>.

<p>As Unicode requires variables to start with an underscore in many 
languages this schema needs to be extended.<sup class="fn">18<span class="fn-text">After 
a proposal by Richard O'Keefe.</span></sup> First we define the two 
classes of named variables.

<p>
<ul class="latex">
<li><i>Named singleton variables</i><br>
Named singletons start with a double underscore (<code>__</code>) or a 
single underscore followed by an uppercase letter. E.g. <code>__var</code> 
or
<code>_Var</code>.

<p>
<li><i>Normal variables</i><br>
All other variables are `normal' variables. Note this makes <code>_var</code> 
a normal variable.<sup class="fn">19<span class="fn-text">Some Prolog 
dialects write variables this way.</span></sup>
</ul>

<p>Any normal variable appearing exactly once in the clause <em>and</em> 
any named singleton variables appearing more than once are reported. 
Below are some examples with warnings in the right column. Singleton 
messages can be suppressed using the <a name="idx:stylecheck1:182"></a><a class="pred" href="debugger.html#style_check/1">style_check/1</a> 
directive.

<p>
<center>
<table border="2" frame="box" rules="groups">
<tr valign="top"><td>test(_).</td></tr>
<tr valign="top"><td>test(_a).</td><td>Singleton variables: [_a] </td></tr>
<tr valign="top"><td>test(_12).</td><td>Singleton variables: [_12] </td></tr>
<tr valign="top"><td>test(A).</td><td>Singleton variables: [A] </td></tr>
<tr valign="top"><td>test(_A).</td></tr>
<tr valign="top"><td>test(__a).</td></tr>
<tr valign="top"><td>test(_, _).</td></tr>
<tr valign="top"><td>test(_a, _a).</td></tr>
<tr valign="top"><td>test(__a, __a).</td><td>Singleton-marked variables 
appearing more than once: [__a] </td></tr>
<tr valign="top"><td>test(_A, _A).</td><td>Singleton-marked variables 
appearing more than once: [_A] </td></tr>
<tr valign="top"><td>test(A, A).</td></tr>
</table>
</center>

<p></body></html>