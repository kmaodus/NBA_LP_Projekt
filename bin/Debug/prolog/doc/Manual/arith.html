<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog 6.3.7 Reference Manual: Section 4.26</title><link rel="home" href="index.html">
<link rel="contents" href="Contents.html">
<link rel="index" href="DocIndex.html">
<link rel="summary" href="summary.html">
<link rel="previous" href="charconv.html">
<link rel="next" href="miscarith.html">

<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

dt.multidef
{ background-color: #c8ffc7;
}

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}
</style>
</head>
<body bgcolor="white">
<div class="navigate"><a class="nav" href="index.html"><img src="home.gif" border=0 alt="Home"></A>
<a class="nav" href="Contents.html"><img src="index.gif" border=0 alt="Contents"></A>
<a class="nav" href="DocIndex.html"><img src="yellow_pages.gif" border=0 alt="Index"></A>
<a class="nav" href="summary.html"><img src="info.gif" border=0 alt="Summary"></A>
<a class="nav" href="charconv.html"><img src="prev.gif" border=0 alt="Previous"></A>
<a class="nav" href="miscarith.html"><img src="next.gif" border=0 alt="Next"></A>
</div>

<h2><a name="sec:4.26"><span class="sec-nr">4.26</span> <span class="sec-title">Arithmetic</span></a></h2>

<a name="sec:arith"></a>

<p>Arithmetic can be divided into some special purpose integer 
predicates and a series of general predicates for integer, floating 
point and rational arithmetic as appropriate. The general arithmetic 
predicates all handle <var>expressions</var>. An expression is either a 
simple number or a <var>function</var>. The arguments of a function are 
expressions. The functions are described in <a class="sec" href="arith.html">section 
4.26.2.3</a>.

<h3><a name="sec:4.26.1"><span class="sec-nr">4.26.1</span> <span class="sec-title">Special 
purpose integer arithmetic</span></a></h3>

<p>The predicates in this section provide more logical operations 
between integers. They are not covered by the ISO standard, although 
they are `part of the community' and found as either library or built-in 
in many other Prolog systems.

<dl class="latex">
<dt class="pubdef"><a name="between/3"><strong>between</strong>(<var>+Low, 
+High, ?Value</var>)</a></dt>
<dd class="defbody">
<var>Low</var> and <var>High</var> are integers, <var><var>High</var> &gt;=<var>Low</var></var>. 
If
<var>Value</var> is an integer, <var><var>Low</var> =&lt;<var>Value</var> 
=&lt;<var>High</var></var>. When <var>Value</var> is a variable it is 
successively bound to all integers between <var>Low</var> and <var>High</var>. 
If <var>High</var> is <code>inf</code> or
<code>infinite</code><sup class="fn">73<span class="fn-text">We prefer <code>infinite</code>, 
but some other Prolog systems already use <code>inf</code> for infinity; 
we accept both for the time being.</span></sup>
<a name="idx:between3:1107"></a><a class="pred" href="arith.html#between/3">between/3</a> 
is true iff <var><var>Value</var> &gt;=<var>Low</var></var>, a feature 
that is particularly interesting for generating integers from a certain 
value.</dd>
<dt class="pubdef"><a name="succ/2"><strong>succ</strong>(<var>?Int1, 
?Int2</var>)</a></dt>
<dd class="defbody">
True if <var><var>Int2</var> = <var>Int1</var> + 1</var> and <var><var>Int1</var> 
&gt;= 0</var>. At least one of the arguments must be instantiated to a 
natural number. This predicate raises the domain error <code>not_less_than_zero</code> 
if called with a negative integer. E.g. <code>succ(X, 0)</code> fails 
silently and <code>succ(X, -1)</code> raises a domain error.<sup class="fn">74<span class="fn-text">The 
behaviour to deal with natural numbers only was defined by Richard 
O'Keefe to support the common count-down-to-zero in a natural way. Up to 
5.1.8, <a name="idx:succ2:1108"></a><a class="pred" href="arith.html#succ/2">succ/2</a> 
also accepted negative integers.</span></sup></dd>
<dt class="pubdef"><a name="plus/3"><strong>plus</strong>(<var>?Int1, 
?Int2, ?Int3</var>)</a></dt>
<dd class="defbody">
True if <var><var>Int3</var> = <var>Int1</var> + <var>Int2</var></var>. 
At least two of the three arguments must be instantiated to integers.
</dd>
</dl>

<h3><a name="sec:4.26.2"><span class="sec-nr">4.26.2</span> <span class="sec-title">General 
purpose arithmetic</span></a></h3>

<a name="sec:arithpreds"></a>

<p>The general arithmetic predicates are optionally compiled (see
<a name="idx:setprologflag2:1109"></a><a class="pred" href="flags.html#set_prolog_flag/2">set_prolog_flag/2</a> 
and the <strong>-O</strong> command line option). Compiled arithmetic 
reduces global stack requirements and improves performance. 
Unfortunately compiled arithmetic cannot be traced, which is why it is 
optional.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name=">/2"><var>+Expr1</var> <strong>&gt;</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
True if expression <var>Expr1</var> evaluates to a larger number than <var>Expr2</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="</2"><var>+Expr1</var> <strong>&lt;</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
True if expression <var>Expr1</var> evaluates to a smaller number than <var>Expr2</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="=</2"><var>+Expr1</var> <strong>=&lt;</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
True if expression <var>Expr1</var> evaluates to a smaller or equal 
number to <var>Expr2</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name=">=/2"><var>+Expr1</var> <strong>&gt;=</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
True if expression <var>Expr1</var> evaluates to a larger or equal 
number to <var>Expr2</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="=\=/2"><var>+Expr1</var> <strong>=\=</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
True if expression <var>Expr1</var> evaluates to a number non-equal to
<var>Expr2</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="=:=/2"><var>+Expr1</var> <strong>=:=</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
True if expression <var>Expr1</var> evaluates to a number equal to <var> 
Expr2</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="is/2"><var>-Number</var> <strong>is</strong> <var>+Expr</var></a></dt>
<dd class="defbody">
True when <var>Number</var> is the value to which <var>Expr</var> 
evaluates. Typically, <a name="idx:is2:1110"></a><a class="pred" href="arith.html#is/2">is/2</a> 
should be used with unbound left operand. If equality is to be tested, <a class="pred" href="arith.html#=:=/2">=:=/2</a> 
should be used. For example:

<p>
<center>
<table border="0" frame="void" rules="groups">
<tr valign="top"><td><code>?- 1 is sin(pi/2).</code> </td><td>Fails! 
sin(pi/2) evaluates to the float 1.0, which does not unify with the 
integer 1. </td></tr>
<tr valign="top"><td><code>?- 1 =:= sin(pi/2).</code> </td><td>Succeeds 
as expected.</td></tr>
</table>
</center>
</dd>
</dl>

<h4><a name="sec:4.26.2.1"><span class="sec-nr">4.26.2.1</span> <span class="sec-title">Arithmetic 
types</span></a></h4>

<a name="sec:artypes"></a>

<p><a name="idx:integerunbounded:1111"></a><a name="idx:rationalnumber:1112"></a><a name="idx:numberrational:1113"></a>SWI-Prolog 
defines the following numeric types:

<p>
<ul class="latex">
<li><i>integer</i><br>
If SWI-Prolog is built using the <em>GNU multiple precision arithmetic 
library</em> <a name="idx:GMP:1114"></a>(GMP), integer arithmetic is <em>unbounded</em>, 
which means that the size of integers is limited by available memory 
only. Without GMP, SWI-Prolog integers are 64-bits, regardless of the 
native integer size of the platform. The type of integer support can be 
detected using the Prolog flags <a class="flag" href="flags.html#flag:bounded">bounded</a>, <a class="flag" href="flags.html#flag:min_integer">min_integer</a> 
and
<a class="flag" href="flags.html#flag:max_integer">max_integer</a>. As 
the use of GMP is default, most of the following descriptions assume 
unbounded integer arithmetic.

<p>Internally, SWI-Prolog has three integer representations. Small 
integers (defined by the Prolog flag <a class="flag" href="flags.html#flag:max_tagged_integer">max_tagged_integer</a>) 
are encoded directly. Larger integers are represented as 64-bit values 
on the global stack. Integers that do not fit in 64 bits are represented 
as serialised GNU MPZ structures on the global stack.

<p>
<li><i>rational number</i><br>
Rational numbers (<var>Q</var>) are quotients of two integers. Rational 
arithmetic is only provided if GMP is used (see above). Rational numbers 
are currently not supported by a Prolog type. They are represented by 
the compound term <code>rdiv(N,M)</code>. Rational numbers that are 
returned from <a name="idx:is2:1115"></a><a class="pred" href="arith.html#is/2">is/2</a> 
are <em>canonical</em>, which means <var>M</var> is positive and <var>N</var> 
and
<var>M</var> have no common divisors. Rational numbers are introduced in 
the computation using the <a class="function" href="arith.html#f-rational/1">rational/1</a>, <a class="function" href="arith.html#f-rationalize/1">rationalize/1</a> 
or the <a class="function" href="arith.html#f-rdiv/2">rdiv/2</a> 
(rational division) function. Using the same functor for rational 
division and for representing rational numbers allows for passing 
rational numbers between computations as well as for using <a name="idx:format3:1116"></a><a class="pred" href="format.html#format/3">format/3</a> 
for printing.

<p>In the long term, it is likely that rational numbers will become
<em>atomic</em> as well as a subtype of <em>number</em>. User code that 
creates or inspects the <code>rdiv(M,N)</code> terms will not be 
portable to future versions. Rationals are created using one of the 
functions mentioned above and inspected using <a name="idx:rational3:1117"></a><a class="pred" href="typetest.html#rational/3">rational/3</a>.

<p>
<li><i>float</i><br>
Floating point numbers are represented using the C type <code>double</code>. 
On most of today's platforms these are 64-bit IEEE floating point 
numbers.
</ul>

<p>Arithmetic functions that require integer arguments accept, in 
addition to integers, rational numbers with (canonical) denominator `1'. 
If the required argument is a float the argument is converted to float. 
Note that conversion of integers to floating point numbers may raise an 
overflow exception. In all other cases, arguments are converted to the 
same type using the order below.
<blockquote> integer <var>-&gt;</var> rational number <var>-&gt;</var> 
floating point number
</blockquote>

<h4><a name="sec:4.26.2.2"><span class="sec-nr">4.26.2.2</span> <span class="sec-title">Rational 
number examples</span></a></h4>

<a name="sec:rational"></a>

<p>The use of rational numbers with unbounded integers allows for exact 
integer or <em>fixed point</em> arithmetic under addition, subtraction, 
multiplication and division. To exploit rational arithmetic <a class="function" href="arith.html#f-rdiv/2">rdiv/2</a> 
should be used instead of `/' and floating point numbers must be 
converted to rational using <a class="function" href="arith.html#f-rational/1">rational/1</a>. 
Omitting the <a class="function" href="arith.html#f-rational/1">rational/1</a> 
on floats will convert a rational operand to float and continue the 
arithmetic using floating point numbers. Here are some examples.

<p>
<center>
<table border="0" frame="void" rules="groups">
<tr valign="top"><td>A is 2 rdiv 6</td><td>A = 1 rdiv 3 </td></tr>
<tr valign="top"><td>A is 4 rdiv 3 + 1</td><td>A = 7 rdiv 3 </td></tr>
<tr valign="top"><td>A is 4 rdiv 3 + 1.5</td><td>A = 2.83333 </td></tr>
<tr valign="top"><td>A is 4 rdiv 3 + rational(1.5)</td><td>A = 17 rdiv 6 </td></tr>
</table>
</center>

<p>Note that floats cannot represent all decimal numbers exactly. The 
function <a class="function" href="arith.html#f-rational/1">rational/1</a> 
creates an <em>exact</em> equivalent of the float, while <a class="function" href="arith.html#f-rationalize/1">rationalize/1</a> 
creates a rational number that is within the float rounding error from 
the original float. Please check the documentation of these functions 
for details and examples.

<p>Rational numbers can be printed as decimal numbers with arbitrary 
precision using the <a name="idx:format3:1118"></a><a class="pred" href="format.html#format/3">format/3</a> 
floating point conversion:

<pre class="code">
?- A is 4 rdiv 3 + rational(1.5),
   format('~50f~n', [A]).
2.83333333333333333333333333333333333333333333333333

A = 17 rdiv 6
</pre>

<h4><a name="sec:4.26.2.3"><span class="sec-nr">4.26.2.3</span> <span class="sec-title">Arithmetic 
Functions</span></a></h4>

<a name="sec:functions"></a>

<p>Arithmetic functions are terms which are evaluated by the arithmetic 
predicates described in <a class="sec" href="arith.html">section 4.26.2</a>. 
There are four types of arguments to functions:

<p>
<center>
<table border="0" frame="void" rules="groups">
<tr valign="top"><td><var>Expr</var> </td><td>Arbitrary expression, 
returning either a floating point value or an integer. </td></tr>
<tr valign="top"><td><var>IntExpr</var> </td><td>Arbitrary expression 
that must evaluate to an integer. </td></tr>
<tr valign="top"><td><var>RatExpr</var> </td><td>Arbitrary expression 
that must evaluate to a rational number. </td></tr>
<tr valign="top"><td><var>FloatExpr</var> </td><td>Arbitrary expression 
that must evaluate to a floating point.</td></tr>
</table>
</center>

<p>For systems using bounded integer arithmetic (default is unbounded, 
see <a class="sec" href="arith.html">section 4.26.2.1</a> for details), 
integer operations that would cause overflow automatically convert to 
floating point arithmetic.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f--/1"><strong>-</strong> <var>+Expr</var></a></dt>
<dd class="defbody">
<var><var>Result</var> = -<var>Expr</var></var></dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-+/1"><strong>+</strong> <var>+Expr</var></a></dt>
<dd class="defbody">
<var><var>Result</var> = <var>Expr</var></var>. Note that if <code><code>+</code></code> 
is followed by a number, the parser discards the <code><code>+</code></code>. 
I.e. <code>?- integer(+1)</code> succeeds.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-+/2"><var>+Expr1</var> <strong>+</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
<var><var>Result</var> = <var>Expr1</var> + <var>Expr2</var></var></dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f--/2"><var>+Expr1</var> <strong>-</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
<var><var>Result</var> = <var>Expr1</var> - <var>Expr2</var></var></dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-*/2"><var>+Expr1</var> <strong>*</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
<var><var>Result</var> = <var>Expr1</var> &times; <var>Expr2</var></var></dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-//2"><var>+Expr1</var> <strong>/</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
<var><var>Result</var> = <var>Expr1</var>/<var>Expr2</var></var>. If the 
flag <a class="flag" href="flags.html#flag:iso">iso</a> is <code>true</code>, 
both arguments are converted to float and the return value is a float. 
Otherwise (default), if both arguments are integers the operation 
returns an integer if the division is exact. If at least one of the 
arguments is rational and the other argument is integer, the operation 
returns a rational number. In all other cases the return value is a 
float. See also <a class="function" href="arith.html#f-///2">///2</a> 
and <a class="function" href="arith.html#f-rdiv/2">rdiv/2</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-mod/2"><var>+IntExpr1</var> <strong>mod</strong> <var>+IntExpr2</var></a></dt>
<dd class="defbody">
Modulo, defined as <var>Result</var> = <var>IntExpr1</var> - (<var>IntExpr1</var> 
div <var>IntExpr2</var>) <var> &times; </var> <var>IntExpr2</var>, where <code>div</code> 
is
<em>floored</em> division.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-rem/2"><var>+IntExpr1</var> <strong>rem</strong> <var>+IntExpr2</var></a></dt>
<dd class="defbody">
Remainder of integer division. Behaves as if defined by
<var>Result</var> is <var>IntExpr1</var> - (<var>IntExpr1</var> // <var>IntExpr2</var>) <var> &times; </var> <var>IntExpr2</var></dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-///2"><var>+IntExpr1</var> <strong>//</strong> <var>+IntExpr2</var></a></dt>
<dd class="defbody">
Integer division, defined as <var>Result</var> is <var>rnd_I</var>(<var>Expr1</var>/<var>Expr2</var>) 
. The function <var>rnd_I</var> is the default rounding used by the C 
compiler and available through the Prolog flag
<a class="flag" href="flags.html#flag:integer_rounding_function">integer_rounding_function</a>. 
In the C99 standard, C-rounding is defined as <code>towards_zero</code>.<sup class="fn">75<span class="fn-text">Future 
versions might guarantee rounding towards zero.</span></sup></dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-div/2"><strong>div</strong>(<var>+IntExpr1, 
+IntExpr2</var>)</a></dt>
<dd class="defbody">
Integer division, defined as <var>Result</var> is (<var>IntExpr1</var> - <var>IntExpr1</var> <var>mod</var> <var>IntExpr2</var>) 
// <var>IntExpr2</var>. In other words, this is integer division that 
rounds towards -infinity. This function guarantees behaviour that is 
consistent with
<a class="function" href="arith.html#f-mod/2">mod/2</a>, i.e., the 
following holds for every pair of integers
<var>X,Y</var> where <code>Y =\= 0</code>.

<pre class="code">
        Q is div(X, Y),
        M is mod(X, Y),
        X =:= Y*Q+M.
</pre>

</dd>
<dt class="pubdef"><a name="f-rdiv/2"><var>+RatExpr</var> <strong>rdiv</strong> <var>+RatExpr</var></a></dt>
<dd class="defbody">
Rational number division. This function is only available if SWI-Prolog 
has been compiled with rational number support. See
<a class="sec" href="arith.html">section 4.26.2.2</a> for details.</dd>
<dt class="pubdef"><a name="f-gcd/2"><var>+IntExpr1</var> <strong>gcd</strong> <var>+IntExpr2</var></a></dt>
<dd class="defbody">
Result is the greatest common divisor of <var>IntExpr1</var>, <var>IntExpr2</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-abs/1"><strong>abs</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Evaluate <var>Expr</var> and return the absolute value of it.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-sign/1"><strong>sign</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Evaluate to -1 if <var><var>Expr</var> &lt; 0</var>, 1 if <var><var>Expr</var> 
&gt; 0</var> and 0 if
<var><var>Expr</var> = 0</var>. If <var>Expr</var> evaluates to a float, 
the return value is a float (e.g., -1.0, 0.0 or 1.0). In particular, 
note that sign(-0.0) evaluates to 0.0. See also <a class="function" href="arith.html#f-copysign/1">copysign/1</a></dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-copysign/1"><strong>copysign</strong>(<var>+Expr1, 
+Expr2</var>)</a></dt>
<dd class="defbody">
Evaluate to <var>X</var>, where the absolute value of <var>X</var> 
equals the absolute value of <var>Expr1</var> and the sign of <var>X</var> 
matches the sign of <var>Expr2</var>. This function is based on 
copysign() from C99, which works on double precision floats and deals 
with handling the sign of special floating point values such as -0.0. 
Our implementation follows C99 if both arguments are floats. Otherwise, <a class="function" href="arith.html#f-copysign/1">copysign/1</a> 
evaluates to <var>Expr1</var> if the sign of both expressions matches or 
-<var>Expr1</var> if the signs do not match. Here, we use the extended 
notion of signs for floating point numbers, where the sign of -0.0 and 
other special floats is negative.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-max/2"><strong>max</strong>(<var>+Expr1, 
+Expr2</var>)</a></dt>
<dd class="defbody">
Evaluate to the larger of <var>Expr1</var> and <var>Expr2</var>. Both 
arguments are compared after converting to the same type, but the return 
value is in the original type. For example, max(2.5, 3) compares the two 
values after converting to float, but returns the integer 3.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-min/2"><strong>min</strong>(<var>+Expr1, 
+Expr2</var>)</a></dt>
<dd class="defbody">
Evaluate to the smaller of <var>Expr1</var> and <var>Expr2</var>. See
<a class="function" href="arith.html#f-max/2">max/2</a> for a 
description of type handling.</dd>
<dt class="pubdef"><a name="f-./2"><strong>.</strong>(<var>+Int,[]</var>)</a></dt>
<dd class="defbody">
A list of one element evaluates to the element. This implies <code>"a"</code> 
evaluates to the character code of the letter `a' (97). This option is 
available for compatibility only. It will not work if `<code>style_check(+string)</code>' 
is active, as <code>"a"</code> will then be transformed into a string 
object. The recommended way to specify the character code of the letter 
`a' is <code>0'a</code>.</dd>
<dt class="pubdef"><a name="f-random/1"><strong>random</strong>(<var>+IntExpr</var>)</a></dt>
<dd class="defbody">
Evaluate to a random integer <var>i</var> for which <var>0 =&lt; i &lt; <var>IntExpr</var></var>. 
The system has two implementations. If it is compiled with support for 
unbounded arithmetic (default) it uses the GMP library random functions. 
In this case, each thread keeps its own random state. The default 
algorithm is the <em>Mersenne Twister</em> algorithm. The seed is set 
when the first random number in a thread is generated. If available, it 
is set from <code>/dev/random</code>. Otherwise it is set from the 
system clock. If unbounded arithmetic is not supported, random numbers 
are shared between threads and the seed is initialised from the clock 
when SWI-Prolog was started. The predicate <a name="idx:setrandom1:1119"></a><a class="pred" href="miscarith.html#set_random/1">set_random/1</a> 
can be used to control the random number generator.</dd>
<dt class="pubdef"><a name="f-random_float/0"><strong>random_float</strong></a></dt>
<dd class="defbody">
Evaluate to a random float <var>I</var> for which <var>0.0 &lt; i &lt; 
1.0</var>. This function shares the random state with <a class="function" href="arith.html#f-random/1">random/1</a>. 
All remarks with the function <a class="function" href="arith.html#f-random/1">random/1</a> 
also apply for <a class="function" href="arith.html#f-random_float/0">random_float/0</a>. 
Note that both sides of the domain are <em>open</em>. This avoids 
evaluation errors on, e.g., <a class="function" href="arith.html#f-log/1">log/1</a> 
or <a class="function" href="arith.html#f-//2">//2</a> while no 
practical application can expect 0.0.<sup class="fn">76<span class="fn-text">Richard 
O'Keefe said: ``If you <em>are</em> generating IEEE doubles with the 
claimed uniformity, then 0 has a 1 in <var>2^53 = 1 in 
9,007,199,254,740,992</var> chance of turning up. No program that 
expects [0.0,1.0) is going to be surprised when 0.0 fails to turn up in 
a few millions of millions of trials, now is it? But a program that 
expects (0.0,1.0) could be devastated if 0.0 did turn up.''</span></sup></dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-round/1"><strong>round</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Evaluate <var>Expr</var> and round the result to the nearest integer.</dd>
<dt class="pubdef"><a name="f-integer/1"><strong>integer</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Same as <a class="function" href="arith.html#f-round/1">round/1</a> 
(backward compatibility).</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-float/1"><strong>float</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Translate the result to a floating point number. Normally, Prolog will 
use integers whenever possible. When used around the 2nd argument of
<a name="idx:is2:1120"></a><a class="pred" href="arith.html#is/2">is/2</a>, 
the result will be returned as a floating point number. In other 
contexts, the operation has no effect.</dd>
<dt class="pubdef"><a name="f-rational/1"><strong>rational</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Convert the <var>Expr</var> to a rational number or integer. The 
function returns the input on integers and rational numbers. For 
floating point numbers, the returned rational number <em>exactly</em> 
represents the float. As floats cannot exactly represent all decimal 
numbers the results may be surprising. In the examples below, doubles 
can represent 0.25 and the result is as expected, in contrast to the 
result of <code>rational(0.1)</code>. The function <a class="function" href="arith.html#f-rationalize/1">rationalize/1</a> 
remedies this. See <a class="sec" href="arith.html">section 4.26.2.2</a> 
for more information on rational number support.

<pre class="code">
?- A is rational(0.25).

A is 1 rdiv 4
?- A is rational(0.1).
A = 3602879701896397 rdiv 36028797018963968
</pre>

</dd>
<dt class="pubdef"><a name="f-rationalize/1"><strong>rationalize</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Convert the <var>Expr</var> to a rational number or integer. The 
function is similar to <a class="function" href="arith.html#f-rational/1">rational/1</a>, 
but the result is only accurate within the rounding error of floating 
point numbers, generally producing a much smaller denominator.<sup class="fn">77<span class="fn-text">The 
names <a class="function" href="arith.html#f-rational/1">rational/1</a> 
and <a class="function" href="arith.html#f-rationalize/1">rationalize/1</a> 
as well as their semantics are inspired by Common Lisp.</span></sup>

<pre class="code">
?- A is rationalize(0.25).

A = 1 rdiv 4
?- A is rationalize(0.1).

A = 1 rdiv 10
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-float_fractional_part/1"><strong>float_fractional_part</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Fractional part of a floating point number. Negative if <var>Expr</var> 
is negative, rational if <var>Expr</var> is rational and 0 if <var>Expr</var> 
is integer. The following relation is always true:
<var>X is float_fractional_part(X) + float_integer_part(X)</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-float_integer_part/1"><strong>float_integer_part</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Integer part of floating point number. Negative if <var>Expr</var> is 
negative, <var>Expr</var> if <var>Expr</var> is integer.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-truncate/1"><strong>truncate</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Truncate <var>Expr</var> to an integer. If <var><var>Expr</var> &gt;= 0</var> 
this is the same as <code>floor(Expr)</code>. For <var><var>Expr</var> &lt; 
0</var> this is the same as
<code>ceil(Expr)</code>. That is, <a name="idx:truncate1:1121"></a><span class="pred-ext">truncate/1</span> 
rounds towards zero.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-floor/1"><strong>floor</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Evaluate <var>Expr</var> and return the largest integer smaller or equal 
to the result of the evaluation.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-ceiling/1"><strong>ceiling</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Evaluate <var>Expr</var> and return the smallest integer larger or equal 
to the result of the evaluation.</dd>
<dt class="pubdef"><a name="f-ceil/1"><strong>ceil</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Same as <a class="function" href="arith.html#f-ceiling/1">ceiling/1</a> 
(backward compatibility).</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f->>/2"><var>+IntExpr1</var> <strong>&gt;&gt;</strong> <var>+IntExpr2</var></a></dt>
<dd class="defbody">
Bitwise shift <var>IntExpr1</var> by <var>IntExpr2</var> bits to the 
right. The operation performs <em>arithmetic shift</em>, which implies 
that the inserted most significant bits are copies of the original most 
significant bits.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-<</2"><var>+IntExpr1</var> <strong>&lt;&lt;</strong> <var>+IntExpr2</var></a></dt>
<dd class="defbody">
Bitwise shift <var>IntExpr1</var> by <var>IntExpr2</var> bits to the 
left.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-\//2"><var>+IntExpr1</var> <strong>\/</strong> <var>+IntExpr2</var></a></dt>
<dd class="defbody">
Bitwise `or' <var>IntExpr1</var> and <var>IntExpr2</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-/\/2"><var>+IntExpr1</var> <strong>/\</strong> <var>+IntExpr2</var></a></dt>
<dd class="defbody">
Bitwise `and' <var>IntExpr1</var> and <var>IntExpr2</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-xor/2"><var>+IntExpr1</var> <strong>xor</strong> <var>+IntExpr2</var></a></dt>
<dd class="defbody">
Bitwise `exclusive or' <var>IntExpr1</var> and <var>IntExpr2</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-\/1"><strong>\</strong> <var>+IntExpr</var></a></dt>
<dd class="defbody">
Bitwise negation. The returned value is the one's complement of
<var>IntExpr</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-sqrt/1"><strong>sqrt</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
<var><var>Result</var> = sqrt(<var>Expr</var>)</var>
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-sin/1"><strong>sin</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
<var><var>Result</var> = sin(<var>Expr</var>)</var>. <var>Expr</var> is 
the angle in radians.
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-cos/1"><strong>cos</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
<var><var>Result</var> = cos(<var>Expr</var>)</var>. <var>Expr</var> is 
the angle in radians.
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-tan/1"><strong>tan</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
<var><var>Result</var> = tan(<var>Expr</var>)</var>. <var>Expr</var> is 
the angle in radians.
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-asin/1"><strong>asin</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
<var><var>Result</var> = arcsin(<var>Expr</var>)</var>. <var>Result</var> 
is the angle in radians.
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-acos/1"><strong>acos</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
<var><var>Result</var> = arccos(<var>Expr</var>)</var>. <var>Result</var> 
is the angle in radians.
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-atan/1"><strong>atan</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
<var><var>Result</var> = arctan(<var>Expr</var>)</var>. <var>Result</var> 
is the angle in radians.
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-atan2/2"><strong>atan2</strong>(<var>+YExpr, 
+XExpr</var>)</a></dt>
<dd class="defbody">
<var><var>Result</var> = arctan(<var>YExpr</var>/<var>XExpr</var>)</var>. <var>Result</var> 
is the angle in radians. The return value is in the range <var>[- pi ... 
pi ]</var>. Used to convert between rectangular and polar coordinate 
system.
</dd>
<dt class="pubdef"><a name="f-atan/2"><strong>atan</strong>(<var>+YExpr, 
+XExpr</var>)</a></dt>
<dd class="defbody">
Same as <a class="function" href="arith.html#f-atan2/2">atan2/2</a> 
(backward compatibility).
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-log/1"><strong>log</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Natural logarithm. <var><var>Result</var> = ln(<var>Expr</var>)</var>
</dd>
<dt class="pubdef"><a name="f-log10/1"><strong>log10</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Base-10 logarithm. <var><var>Result</var> = log10(<var>Expr</var>)</var>
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-exp/1"><strong>exp</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
<var><var>Result</var> = e **<var>Expr</var></var>
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-**/2"><var>+Expr1</var> <strong>**</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
<var><var>Result</var> = <var>Expr1</var>**<var>Expr2</var></var>. With 
unbounded integers and integer values for <var>Expr1</var> and a 
non-negative integer
<var>Expr2</var>, the result is always integer. The integer expressions
<var>0 ** I</var>, <var>1 ** I</var> and <var>-1 ** I</var> are 
guaranteed to work for any integer <var>I</var>. Other integer base 
values generate a <code>resource</code> error if the result does not fit 
in memory.
</dd>
<dt class="pubdef"><a name="f-powm/3"><strong>powm</strong>(<var>+IntExprBase, 
+IntExprExp, +IntExprMod</var>)</a></dt>
<dd class="defbody">
<var><var>Result</var> = (<var>IntExprBase</var>**<var>IntExprExp</var>) 
modulo <var>IntExprMod</var></var>. Only available when compiled with 
unbounded integer support. This formula is required for Diffie-Hellman 
key-exchange, a technique where two parties can establish a secret key 
over a public network.
</dd>
<dt class="pubdef"><a name="f-^/2"><var>+Expr1</var> <strong>^</strong> <var>+Expr2</var></a></dt>
<dd class="defbody">
Same as <a class="function" href="arith.html#f-**/2">**/2</a> (backward 
compatibility).
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="f-pi/0"><strong>pi</strong></a></dt>
<dd class="defbody">
Evaluate to the mathematical constant <var>pi</var> (3.14159 ... ).
</dd>
<dt class="pubdef"><a name="f-e/0"><strong>e</strong></a></dt>
<dd class="defbody">
Evaluate to the mathematical constant <var>e</var> (2.71828 ... ).
</dd>
<dt class="pubdef"><a name="f-epsilon/0"><strong>epsilon</strong></a></dt>
<dd class="defbody">
Evaluate to the difference between the float 1.0 and the first larger 
floating point number.</dd>
<dt class="pubdef"><a name="f-cputime/0"><strong>cputime</strong></a></dt>
<dd class="defbody">
Evaluate to a floating point number expressing the <font size=-1>CPU</font> 
time (in seconds) used by Prolog up till now. See also <a name="idx:statistics2:1122"></a><a class="pred" href="statistics.html#statistics/2">statistics/2</a> 
and <a name="idx:time1:1123"></a><a class="pred" href="statistics.html#time/1">time/1</a>.</dd>
<dt class="pubdef"><a name="f-eval/1"><strong>eval</strong>(<var>+Expr</var>)</a></dt>
<dd class="defbody">
Evaluate <var>Expr</var>. Although ISO standard dictates that `<var>A</var>=1+2, <var>B</var> 
is
<var>A</var>' works and unifies <var>B</var> to 3, it is widely felt 
that source level variables in arithmetic expressions should have been 
limited to numbers. In this view the eval function can be used to 
evaluate arbitrary expressions.<sup class="fn">78<span class="fn-text">The <a class="function" href="arith.html#f-eval/1">eval/1</a> 
function was first introduced by ECLiPSe and is under consideration for 
YAP.</span></sup>
</dd>
</dl>

<p><b>Bitvector functions</b> 

<p>The functions below are not covered by the standard. The
<a class="function" href="arith.html#f-msb/1">msb/1</a> function is 
compatible with hProlog. The others are private extensions that improve 
handling of ---unbounded--- integers as bit-vectors.

<dl class="latex">
<dt class="pubdef"><a name="f-msb/1"><strong>msb</strong>(<var>+IntExpr</var>)</a></dt>
<dd class="defbody">
Return the largest integer <var>N</var> such that <code>(IntExpr &gt;&gt; N) /\ 1 =:= 1</code>. 
This is the (zero-origin) index of the most significant 1 bit in the 
value of <var>IntExpr</var>, which must evaluate to a positive integer. 
Errors for 0, negative integers, and non-integers.</dd>
<dt class="pubdef"><a name="f-lsb/1"><strong>lsb</strong>(<var>+IntExpr</var>)</a></dt>
<dd class="defbody">
Return the smallest integer <var>N</var> such that <code>(IntExpr &gt;&gt; N) /\ 1 =:= 1</code>. 
This is the (zero-origin) index of the least significant 1 bit in the 
value of <var>IntExpr</var>, which must evaluate to a positive integer. 
Errors for 0, negative integers, and non-integers.</dd>
<dt class="pubdef"><a name="f-popcount/1"><strong>popcount</strong>(<var>+IntExpr</var>)</a></dt>
<dd class="defbody">
Return the number of 1s in the binary representation of the non-negative 
integer <var>IntExpr</var>.
</dd>
</dl>

<p></body></html>